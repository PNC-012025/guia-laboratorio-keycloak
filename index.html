
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Integracion Keycloak con SpringBoot (Patron BFF)</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="codelab-deployment"
                  title="Integracion Keycloak con SpringBoot (Patron BFF)"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Conceptos Basicos" duration="0">
        <h2 is-upgraded>¿Que es Keycloak?</h2>
<p>Keycloak es un producto de software de código abierto que permite el inicio de sesión único con gestión de identidades y accesos, diseñado para aplicaciones y servicios modernos.</p>
<h2 is-upgraded>Patron BFF</h2>
<p>El patrón BFF hace referencia al concepto de Backend For FrontEnd. Cuando nosotros diseñamos muchas de nuestras aplicaciones nos encontramos en situaciones en las que tenemos diseñado un FrontEnd realizado en JavaScript contra un Backend desarrollado en la tecnología que nos plazca pero muchas veces enfocado a Servicios REST  . En muchos casos el BackEnd esta diseñado de una forma neutra es decir publica una información de la que cualquier cliente puede beneficiarse . Eso sí cada cliente dispondrá de un interface de usuario diferente a otros . Al publicar la información de forma muy neutra todos los clientes se adaptarán a ella  , pero cada uno de los cuales necesitará realizar un esfuerzo diferente para cargar los datos necesarios que presenta. <a href="https://www.arquitecturajava.com/que-es-el-patron-bff/" target="_blank">Fuente: ArquiteturaJava</a></p>
<h2 is-upgraded>¿Por que BFF con Keycloak?</h2>
<p>Usando un patron BFF en nuestro Backend tenemos las siguientes ventajas</p>
<ul>
<li><h3 is-upgraded>1 - Separacion de preocupaciones</h3>
<ul>
<li>El frontend se centra en la UI, y no necesita preocuparse por autenticación compleja ni detalles de autorización.</li>
<li>El BFF se encarga de la autenticación con Keycloak, gestión de tokens, transformación de datos, y llamadas a APIs internas.</li>
</ul>
</li>
<li><h3 is-upgraded>2 - Seguridad y control de acceso</h3>
<ul>
<li>El BFF maneja la validación del JWT, verifica roles/permisos y controla qué rutas están permitidas.</li>
<li>El frontend nunca toca directamente Keycloak ni otros microservicios.</li>
</ul>
</li>
<li><h3 is-upgraded>3 - Mejor manejo de tokens</h3>
<ul>
<li>El BFF puede usar tokens más seguros (HttpOnly cookies) y mantener tokens de refresco lejos del frontend.</li>
<li>También puede actuar como proxy para renovar tokens automáticamente.</li>
</ul>
</li>
<li><h3 is-upgraded>4 - Customizacion por cliente</h3>
<ul>
<li>Una app móvil puede tener distintos requerimientos de datos que una app web.</li>
<li>Con BFF, cada frontend tiene su propio backend adaptado a sus necesidades (datos resumidos, transformados, cacheados, etc.).</li>
</ul>
</li>
<li><h3 is-upgraded>5 - Facilita cambios sin afectar todo</h3>
<ul>
<li>Cambios en un BFF solo afectan a su cliente.</li>
<li>Es más fácil de probar, desplegar y mantener.</li>
</ul>
</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Keycloak con Docker" duration="0">
        <h2 is-upgraded>Instalacion de una instancia de Keycloak</h2>
<p>Para esta practica, usaremos una instancia de desarrollo de Keycloak, para esto, utilizaremos docker con la imagen oficial de Keycloak. Para esto, usaremos el siguiente comando:</p>
<pre><code language="language-bash" class="language-bash">docker run -p 3030:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:26.2.5 start-dev
</code></pre>
<aside class="warning"><h3 is-upgraded>⚠️ Aclaracion</h3>
<p>Por lo general, los puertos utilizados para Keycloak son el 8080:8080, pero para esta ocasion, ya que nuestra api estara corriendo en el puerto 8080, definiremos que estaremos usando el puerto 8080 interno de nuestro contenedor, expuesto en el puerto 3030 de nuestro ordenador.</p>
</aside>
<h2 is-upgraded>Acceso a la terminal administrativa</h2>
<p>La primera vez que realicemos este proceso, puede que tarde un poco, ya que se tendra que descargar la imagen a utilizar. Una vez que la imagen haya sido descargada y que la instancia este corriendo, accederemos a la siguiente ruta</p>
<p><a href="http://localhost:3030/admin" target="_blank">Ruta de la instancia</a></p>
<p>En la que debera verse la siguiente pantalla</p>
<p class="image-container"><img alt="alt-text-here" src="img/b948df5b49f74f2c.png"></p>
<p>Una vez en esta pantalla, necesitamos las credenciales que hemos determinado en el comando de la creacion de instancia</p>
<pre><code language="language-bash" class="language-bash">KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin
</code></pre>
<p>En estos parametros es donde se definen las crecenciales de nuestro usuario <strong>temporal</strong>. Por tanto, nuestras credenciales seran:</p>
<h3 is-upgraded>Username or email</h3>
<p>admin</p>
<h3 is-upgraded>Password</h3>
<p>admin</p>
<p>Si hemos ingresado los datos correctamente, deberiamos acceder a la siguiente pantalla</p>
<p class="image-container"><img alt="alt-text-here" src="img/75c24a39edfe77ad.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Configuracion de Keycloak" duration="0">
        <h2 is-upgraded>Pasos escenciales</h2>
<p>Una vez que hayamos entrado en la pantalla administrativa de nuestra instancia, necesitaremos hacer numero cosas escenciales, las cuales son:</p>
<ul>
<li>Definir un usuario <strong>no temporal</strong></li>
<li>Crear un realm</li>
<li>Crear un client</li>
<li>Definir roles</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Definir un usuario 
no temporal" duration="0">
        <p>Si vemos la pantalla inicia de nuestra pantalla de inicio, veremos la siguiente advertencia <img alt="alt-text-here" src="img/28e7e13e328cedc.png"></p>
<p>Para resolver esta advertencia, deberemos seguir los siguientes pasos:</p>
<h2 is-upgraded>Acceder a la seccion users</h2>
<p>En nuestra barra lateral izquierda, encontraremos una lista de funciones o carateristicas a las que podemos acceder, en este caso, haremos clic en la opcion &#34;Users&#34;</p>
<p class="image-container"><img alt="alt-text-here" src="img/4b16ee1093716d7.png"></p>
<p>La cual nos mostrara la siguiente seccion</p>
<p class="image-container"><img alt="alt text" src="img/2378e00450aed660.png"></p>
<p>En la cual estara registrado solo nuestro usuario temporal llamado <strong>admin</strong>. Haremos clic en el boton azul que dice <strong>Add User</strong>, el cual nos llevara el siguiente formulario</p>
<p class="image-container"><img alt="alt text" src="img/5268d9c9bd65f13b.png"></p>
<p>El cual deberemos llenar con los datos que creamos convenientes.</p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Se debe marcar la casilla de <strong>Email verified</strong>. De lo contrario, el usuario estara marcado como <strong>Usuario sin completar</strong> y podria dificultar algunos proceso.</p>
</aside>
<p>Presionamos el boton <strong>Create</strong> y nos llevara a la siguiente etapa</p>
<p class="image-container"><img alt="alt text" src="img/26459e17887d49b0.png"></p>
<p>Aca nos interesan dos cosas</p>
<ul>
<li>Credentiales</li>
<li>Role Mapping</li>
</ul>
<h2 is-upgraded>Definir credenciales</h2>
<p>Primero nos dirigiremos a <strong>Credentials</strong>, en donde tendremos que definir la manera en la que nuestro usuario accedera a la seccion administrativa.</p>
<p class="image-container"><img alt="alt text" src="img/2858b0c10765c9d4.png"></p>
<p>Presionaremos el boton <strong>Set Password</strong> y llenaremos los campos necesarios.</p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Debemos asegurarnos que el atributo con el nombre <strong>Temporary</strong> se encuentre en OFF. De lo contrario, despues del primero Login, tendremos que cambiar la contrasena.</p>
</aside>
<p>Presionamos <strong>Save</strong> y luego <strong>Save Password</strong> y nuestra contrasena habra sido establecida.</p>
<h2 is-upgraded>Definir roles</h2>
<p>Una vez definidas nuestras credenciales, ahora necesitamos definir que el usuario sera el administrador de toda la instancia. Para esto, primero debemos asegurarnos que nos encontramos en el realm <strong>Master</strong>. Para ello, en la barra lateral izquierda, encontraremos la opcion llamada <strong>Manage realms</strong></p>
<p class="image-container"><img alt="alt text" src="img/53af4be576c3cd9.png"></p>
<p>Damos clic, y nos aseguramos de que el Realm con el nombre &#34;mastes&#34; se encuentre con la etiqueta <strong>Current realm</strong>, de la siguiente forma</p>
<p class="image-container"><img alt="alt text" src="img/36731baf75454dac.png"></p>
<p>Volvemos a nuestra seccion de usuarios, damos clic en el nombre del usuario que habiamos creados en anterioridad y no dirigiremos al apartado de <strong>Role Mapping</strong></p>
<p class="image-container"><img alt="alt text" src="img/fed023b8c4c97e62.png"></p>
<p>Daremos clic en el boton <strong>Assign role</strong>, la cual desplegara el siguiente menu:</p>
<p class="image-container"><img alt="alt text" src="img/f113bba68db82984.png"></p>
<p>En la parte superior izquierda, encontraremos un icono para filtrar, el cual dice <strong>&#34;Filter by clients&#34;</strong> daremos clic sobre el y seleccionaremos <strong>&#34;Filter by realm roles&#34;</strong>. Los roles mostrados en pantalla se actualizaran, mostrandonos los siguientes:</p>
<p class="image-container"><img alt="alt text" src="img/13eb37fdf34765c5.png"></p>
<p>Marcaremos con un cheque el rol que dice <strong>&#34;admin&#34;</strong> y daremos clic en <strong>Assign</strong>.</p>
<p>Una vez asignado, los roles de nuestro usuario deberia verse asi:</p>
<p class="image-container"><img alt="alt text" src="img/bb9cd33b3ef05f38.png"></p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Una vez hecho este proceso, debemos ir a la parte superior derecha, hacer clic sobre el desplegable que dice &#34;admin&#34; y hacer un Sign out para iniciar sesion con el usuario que hemos creado con anterioridad.</p>
</aside>
<aside class="warning"><h3 is-upgraded>⚠️ Eliminacion de usuario temporal</h3>
<p>Cuando hayamos ingresado con nuestro nuevo usuario, deberemos ir al apartado de users y asegurarnos de borrar al usuario temporal para ello solo debemos dar clic en el cheque al lado del usuario y luego presionar el botn &#34;Delete user&#34;.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Crear un realm" duration="0">
        <h2 is-upgraded>¿Que es un realm?</h2>
<p>Un realm en Keycloak (y en general en contextos de seguridad y autenticación) es una unidad de aislamiento que agrupa usuarios, roles, clientes y configuraciones de seguridad de manera completamente independiente de otros realms.</p>
<p>Es decir, podemos tener multiples realm para distintos sistemas, en donde cada uno de sus usuarios, roles, configuraciones, clientes, etc, son distintos.</p>
<h2 is-upgraded>Creando un realm</h2>
<p>Despues de haber creado nuestro usuarios, habernos logeado y borrado el usuario temporal. Necesitamos crear un entorno en donde se estaran almacenando nuestros usuarios, para ello, iremos al apartado de Manage Realms (como lo habiamos hecho con anterioridad)</p>
<p class="image-container"><img alt="alt text" src="img/53af4be576c3cd9.png"></p>
<p>Y presionaremos el boton <strong>Create realm</strong>, el cual nos desplegara el siguiente formulario</p>
<p class="image-container"><img alt="alt text" src="img/6b1164d2118aead5.png"></p>
<p>En el cual, solo sera necesario llenar el campo de <strong>Realm name</strong></p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Deberemos dejar marcada la opcion de Enabled</p>
</aside>
<aside class="special"><h3 is-upgraded>✅ Realm creado con exito.</h3>
<p>Automaticamente nuestro realm haya sido creado, nos daremos cuenta que en la parte superior izquierda, el current realm ha camiado Si esto no sucede, sera necesario que hagamos el cambio manualmente en la seccion de Manage Realms.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Crear un client" duration="0">
        <h2 is-upgraded>¿Que es un client?</h2>
<p>En el contexto de Keycloak, un Client (cliente) es una aplicación que quiere autenticarse usando Keycloak. Puede ser una app web, un frontend, un backend, una app móvil, una API... cualquier cosa que requiera autenticación/autorización gestionada por Keycloak.</p>
<h2 is-upgraded>Por que es importante?</h2>
<p>Como su concepto lo dice, son aplicaciones que estaran permitidas a autenticarse y a hacer uso de nuestras instancias de keycloak. Ejemplo: Si queremos crear un usuario, las peticiones deben venir desde una fuente confiable que este autorizada por nuestra instancia.</p>
<h2 is-upgraded>Creando un client</h2>
<p>Para crear un Client, debemos dirigirnos a la seccion de Clients en nuestra pantalla de administracion de Keycloak</p>
<p class="image-container"><img alt="alt text" src="img/c7cd4a3c3355a455.png"></p>
<h3 is-upgraded>Datos generales</h3>
<p>Una vez en la seccion, presionaremos el boton de <strong>Create client</strong>, el cual nos dirigira al siguiente formulario:</p>
<p class="image-container"><img alt="alt text" src="img/5765e87b34141f73.png"></p>
<p>El cual, para este ejemplo llenaremos de la siguiente manera:</p>
<p class="image-container"><img alt="alt text" src="img/d84eedd6b544bc97.png"></p>
<aside class="special"><h3 is-upgraded>Significado de campos.</h3>
<ul>
<li><strong>Client Type</strong> El tipo de conexion y de cliente que se encargara de gestionar la autenticacion, en este caso, OpenID Connect</li>
<li><strong>Client ID</strong> Idetificador de nuestro Client (importante recordarlo)</li>
<li><strong>Name</strong> Alias de nuestro cliente</li>
<li><strong>Description</strong> Una breve descripcion de nuestro cliente</li>
<li><strong>Always display in UI</strong> Esta opcion es utilizado si no estamos utilizando el patron BFF. Esta opcion mostrara en la pantalla de login a que cliente se quiere logear. En nuestro caso, no es necesario, ya que las operaciones se estaran realizando a traves de nuestra api.</li>
</ul>
</aside>
<h3 is-upgraded>Metodos de autenticacion</h3>
<p>Al haber llenado los campos y presionar el boton <strong>Next</strong>, nos dirigira al formulario de metodos de autenticacion. En el cual, para nuestro caso, configuraremos de la siguiente manera:</p>
<p class="image-container"><img alt="alt text" src="img/9575467e046ba571.png"></p>
<p>Damos al boton <strong>Next</strong>, acto seguido,  damos en el boton de <strong>Save</strong></p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Los campos del formulario <strong>Loggin Settings</strong> no deben llenarse para esta ocasion</p>
</aside>
<aside class="special"><h3 is-upgraded>✅ Client creado con exito.</h3>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Definicion de roles en Client" duration="0">
        <h2 is-upgraded>Realm roles vs Client Roles</h2>
<p>Ahora que ya hemos creado nuestro client y nuestro realm, hay que definir que roles existiran dentro de nuestro ecosistema. Y es aquin en donde entra la pregunta ¿En donde los creo?. Ya que si nos dirigimos a la barra lateral izquierda, podemos ver la seccion llamada &#34;Real Roles&#34;. Pero si nos vamos a la seccion de clientes y seleccionamos el que creamos con anterioridad, veremos que tambien hay un apartado de roles.</p>
<h3 is-upgraded>¿Cual es la mejor opcion?</h3>
<p>Pues en realidad, depende de de la orientacion que le queremos dar</p>
<ul>
<li>Realm roles Se utiliza cuando queremos que nuestros roles tengan un alcance global en nuestro realm, es decir, independientemente el cliente que se conecte a nuestro realm, los roles seran los mismos</li>
<li>Client roles Se utiliza cuando se quieren que los roles solo sean creados para un cliente en especifico.</li>
</ul>
<p>En esta ocasion, ya que estamos haciendo un patron BFF y el unico que podra acceder a nuestro Keycloak, es nuestra API a traves de su cliente, optaremos por crear roles en nuestro cliente.</p>
<p>Para ello, nos dirigimos a la seccion de <strong>Clients</strong> hacemos clic en el que hemos creado, vamos al apartado de <strong>Roles</strong>, damos clic en <strong>Create role</strong> y creamos uno. Ejemplo:</p>
<p class="image-container"><img alt="alt-text-here" src="img/349c48631fea06b2.png"></p>
<h2 is-upgraded>Nuestro cliente y sus roles</h2>
<p>Hemos visto como crear roles para los usuarios que estara registrandose en nuestra API, pero aun no sabemos que permisos tiene nuestro cliente, ya que, si este estara conectandose mediante algun metodo con Keycloak, tambien necesito algun metodo de autenticacion y por ende, sus propios roles. Su metodo de autenticacion ya ha sido definido cuando lo creamos, mediante un <strong>Client secret</strong>. Pero sus roles propios no han sido definidos en ningun momento.</p>
<p>Para ello, en la pantalla de nuestro Client, nos dirigiremos al apartado de <strong>Service Accounts Roles</strong>, la cual nos mostrara la pantalla siguiente:</p>
<p class="image-container"><img alt="alt-text-here" src="img/bb23d7ebd16ce0a3.png"></p>
<p>Daremos clic en <strong>Assign Role</strong> y en la barra de busqueda escribiremos algunas frases y habilitaremos los siguitenes roles</p>
<ul>
<li>Buscar: <strong>realm</strong><ul>
<li>Habilitar: <strong>manage-users</strong></li>
</ul>
</li>
<li>Buscar: <strong>view</strong><ul>
<li>Habilitar: <strong>view-users</strong></li>
</ul>
</li>
<li>Buscar: <strong>token</strong><ul>
<li>Habilitar: <strong>read-token</strong></li>
</ul>
</li>
</ul>
<p>Y los roles de nuestro cliente deberian quedar de la siguiente forma:</p>
<p class="image-container"><img alt="alt-text-here" src="img/3af88ddc7382187b.png"></p>
<aside class="special"><h3 is-upgraded>✅ Client configurado con exito</h3>
<p>Ahora que nuestro Client ha sido configurado correctamente, tiene la capacidad de hacer peticiones a nuestra instancia de Keycloak. Todas estas configuraciones serviran para que podamos autenticar usuarios de devolverles su token y algunas otras propiedades que configuraremos mas adelante. Al mismo tiempo, estas configuraciones tienen la capacidad de no darle tanto poder administrativo a nuestro client y que solo tenga la capacidad de manejar cosas escenciales</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Configuracion de proyecto con SpringBoot" duration="0">
        <h2 is-upgraded>Nuevas dependencias</h2>
<p>Ya hemos configurado correctamente nuestro Keycloak para que podamos hacer peticiones desde nuestro backend. Pero nuestro backend aun no esta implementado. Para esto, necesitaremos inicializar un nuevo proyecto con algunas dependencias nuevas y unas nuevas configuraciones. Primero, iniciaremos un proyecto con las mismas caracteristicas que hemos usado con anterioridad</p>
<aside class="warning"><h3 is-upgraded>⚠️ Importante</h3>
<p>Por el momento solo definiremos las tecnologias y caracteristicas generales de nuestra aplicacion. Las dependencias cambiaran.</p>
</aside>
<p class="image-container"><img alt="alt-text-here" src="img/3e91b64c64656a05.png"></p>
<p>Para nuestras dependencias, ahora tendremos unas cuantas nuevas, entre las cuales se encuentran:</p>
<ul>
<li>OpenFein</li>
<li>Spring Security</li>
<li>OAuth2 Resource Server</li>
</ul>
<p>Quedando nuestra seccion de dependencias de la siguiente forma:</p>
<p class="image-container"><img alt="alt-text-here" src="img/2d9cd5286822fbe5.png"></p>
<p>Presionamos <strong>Create</strong> y esperamos a que neustro proyecto haga su build</p>
<aside class="warning"><h3 is-upgraded>⚠️ Advertencia</h3>
<p>Si por alguna razon los setters o getters les llegaran a problemas, cambiar la dependencia de lombok por lo siguiente:</p>
<pre><code language="language-xml" class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
  	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  	&lt;artifactId&gt;lombok&lt;/artifactId&gt;
  	&lt;version&gt;1.18.38&lt;/version&gt;
  	&lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code language="language-xml" class="language-xml">   &lt;plugin&gt;
  	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  	&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  	&lt;configuration&gt;
  		&lt;annotationProcessorPaths&gt;
  			&lt;path&gt;
  				&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  				&lt;artifactId&gt;lombok&lt;/artifactId&gt;
  				&lt;version&gt;1.18.38&lt;/version&gt;
  			&lt;/path&gt;
  		&lt;/annotationProcessorPaths&gt;
  	&lt;/configuration&gt;
  &lt;/plugin&gt;
</code></pre>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

<script>
  const fabs = document.querySelector("#fabs");
  const done = document.querySelector("#done");
  const codelabNavButtons = document.querySelector("#codelab-nav-buttons");
  const arrowBack = document.querySelector("#arrow-back");
  fabs.removeChild(done);
  codelabNavButtons.removeChild(arrowBack);
</script>
</body>
</html>
